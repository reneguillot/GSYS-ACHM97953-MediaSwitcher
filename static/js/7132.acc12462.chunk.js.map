{"version":3,"file":"static/js/7132.acc12462.chunk.js","mappings":"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","sources":["components/home/Home.js"],"sourcesContent":["import React, { useEffect } from 'react';\r\n\r\nimport { useSelector } from 'react-redux';\r\n\r\n// Services and utilities\r\nimport { GCloud } from 'services/gcloud';\r\nimport { logToConsole } from 'components/utils';\r\n\r\n// Genesys Spark UI\r\nimport { GuxCardBeta, GuxInlineAlertBeta, GuxTableBeta, GuxToggle } from 'genesys-spark-components-react';\r\nimport { registerElements } from 'genesys-spark-components';\r\nimport 'genesys-spark-components/dist/genesys-webcomponents/genesys-webcomponents.css';\r\nregisterElements();\r\n\r\nimport './Home.css';\r\n\r\nconst Home = () => {\r\n    const [queueList, setQueueList] = React.useState([]);\r\n    const [configuredMediaTypes, setConfiguredMediaTypes] = React.useState([]);\r\n    const [relevantMediaTypes, setRelevantMediaTypes] = React.useState([]);\r\n    const [agentId, setAgentId] = React.useState(undefined);\r\n    const [exception, setException] = React.useState(undefined);\r\n\r\n    const debugMode = useSelector((state) => state.debugMode.value);\r\n\r\n    /**\r\n     * GuxToggle click event handler, immediately updating queue joined status\r\n     * @param {GuxToggleCustomEvent<boolean>} e The event object, also including GuxToggle component reference\r\n     * @param {string} mediaType The associated media type with the GuxToggle component\r\n     * @returns \r\n     */\r\n    const onToggleClick = (e, mediaType) => {\r\n        updateQueueStatus(mediaType, e.detail);\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Determines whether a given queue is media type compliant. This check is based upon inspecting queue\r\n     * name according to a naming convention consisting of different parts. Parts are divided with underscore:\r\n     * - Part 1: country (code); usually two characters in UPPERcase, but not explicitly enforced\r\n     * - Part 2: media type, should be a single word\r\n     * - Part 3: department / topic / queue name; this last part may include underscore characters as well\r\n     * @param {string} queueName Queue name\r\n     * @param {array} supportedMediaTypes List of supported (configured) media types\r\n     * @returns Undefined whenever queue name is not compliant, otherwise the media type itself\r\n     */\r\n    const isCompliantMediaTypeQueue = (queueName, supportedMediaTypes) => {\r\n        const queueNameParts = queueName.split('_');\r\n        if (queueNameParts.length >= 3) {\r\n            const queueMediaType = queueNameParts[1].toLowerCase()\r\n            return (supportedMediaTypes.hasOwnProperty(queueMediaType)) ? queueMediaType : undefined;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * From two lists (supported media types as configured and the list of agent queues), determine which list of media types\r\n     * is applicable for this agent. This may be a subset of all supported media types\r\n     * @param {array} thisQueueList The list of agent queues\r\n     * @param {array} thisSupportedMediaTypes The list of (configured) supported media types\r\n     * @returns List of relevant media types for the agent and join status (grouped by media type)\r\n     */\r\n    const filterApplicableMediaTypes = (thisQueueList, thisSupportedMediaTypes) => {\r\n        let mediaTypes = [];\r\n\r\n        for (let idx = 0; idx < thisQueueList.length; idx++) {\r\n            const thisQueueName = thisQueueList[idx].name\r\n            const thisQueueJoinStatus = thisQueueList[idx].joined\r\n\r\n            const compliantMediaType = isCompliantMediaTypeQueue(thisQueueName, thisSupportedMediaTypes);\r\n            if (compliantMediaType) {\r\n                const filteredMediaType = mediaTypes.filter(mediaType => {\r\n                    return mediaType.mediaType == compliantMediaType\r\n                });\r\n\r\n                if (filteredMediaType.length == 0) {\r\n                    mediaTypes.push(\r\n                    {   mediaType: compliantMediaType,\r\n                        label: thisSupportedMediaTypes[compliantMediaType],\r\n                        joinStatus: thisQueueJoinStatus\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return mediaTypes;\r\n    };\r\n\r\n    /**\r\n     * Update all queues related to given media type with given new queue joined status\r\n     * @param {string} mediaType The media type to update queue status for\r\n     * @param {boolean} newStatus The new queue joined status\r\n     */\r\n    const updateQueueStatus = async (mediaType, newStatus) => {\r\n        try {\r\n            logToConsole(debugMode, `Home:UpdateQueueStatus:Start - [${mediaType}] queues to new status [${newStatus}]`);\r\n\r\n            if (agentId) {\r\n                let newQueueStatusList = [];\r\n                for (let idx = 0; idx < queueList.length; idx++) {\r\n                    const thisQueueName = queueList[idx].name;\r\n                    const thisQueueId = queueList[idx].id;\r\n    \r\n                    const compliantMediaType = isCompliantMediaTypeQueue(thisQueueName, configuredMediaTypes);\r\n                    if (compliantMediaType == mediaType) {\r\n                        newQueueStatusList.push({\r\n                                id: thisQueueId,\r\n                                joined: newStatus\r\n                        });\r\n                    }\r\n                }\r\n    \r\n                await GCloud.patchUserQueues(agentId, newQueueStatusList);\r\n                updateQueueList(newQueueStatusList);\r\n                logToConsole(debugMode, 'Home:UpdateQueueStatus:End', newQueueStatusList);\r\n            }\r\n            else {\r\n                logToConsole(debugMode, 'Home:UpdateQueueStatus:UnknownAgentId');\r\n            }\r\n\r\n            setException(undefined);\r\n        }\r\n        catch (err) {\r\n            logToConsole(debugMode, 'Home:UpdateQueueStatus:Exception', err);\r\n            setException(err);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Update the agent assigned list of queues with (one or more) new joined statuses\r\n     * @param {array} newQueueStatusList List of queues with new joined status\r\n     */\r\n    const updateQueueList = (newQueueStatusList) => {\r\n        let updatedList = queueList;\r\n        updatedList = updatedList.map(queue => {\r\n            const foundElement = newQueueStatusList.filter(newQueueStatus =>\r\n                newQueueStatus.id == queue.id\r\n            );\r\n            if (foundElement.length == 1) {\r\n                queue.joined = foundElement[0].joined;\r\n            }\r\n            \r\n            return queue;\r\n        });\r\n\r\n        const relevantAgentMedia = filterApplicableMediaTypes(updatedList, configuredMediaTypes);\r\n        setRelevantMediaTypes(relevantAgentMedia);\r\n        setQueueList(updatedList);\r\n    }\r\n\r\n    useEffect(() => {\r\n        const loadGCXData = async() => {\r\n            try {\r\n                const usersMeData = await GCloud.getCurrentUser();\r\n                if (usersMeData.id) {\r\n                    logToConsole(debugMode, 'Home:Init:AgentID', usersMeData.id);\r\n                    setAgentId(usersMeData.id);\r\n    \r\n                    const userQueuesData = await GCloud.getUserQueues(usersMeData.id);\r\n                    logToConsole(debugMode, 'Home:Init:UserQueues', userQueuesData);\r\n                    setQueueList(userQueuesData);\r\n    \r\n                    const configuredMediaTypes = await GCloud.getSupportedMediaTypes();\r\n                    logToConsole(debugMode, 'Home:Init:SupportedMediaTypes', configuredMediaTypes);\r\n                    setConfiguredMediaTypes(configuredMediaTypes);\r\n    \r\n                    const relevantAgentMedia = filterApplicableMediaTypes(userQueuesData, configuredMediaTypes);\r\n                    setRelevantMediaTypes(relevantAgentMedia);\r\n                    logToConsole(debugMode, 'Home:Init:RelevantMediaTypes', relevantAgentMedia);\r\n                }\r\n            }\r\n            catch (err) {\r\n                console.log(err);\r\n                setException(err);\r\n            }\r\n        }\r\n\r\n        logToConsole(debugMode, 'Home:Init - Initializing Media Switcher');\r\n        loadGCXData();\r\n    }, []);\r\n\r\n    return (\r\n        <div>\r\n            { exception && <GuxInlineAlertBeta accent='error'>{ exception.code } - {exception.message }</GuxInlineAlertBeta> }\r\n            <h1>Media Switcher</h1>\r\n            <GuxCardBeta className=\"toggle-area\">\r\n                { relevantMediaTypes.map(mediaType => (\r\n                    <GuxToggle\r\n                            key={ mediaType.mediaType }\r\n                            checked={ mediaType.joinStatus }\r\n                            id={ mediaType.mediaType }\r\n                            checkedLabel={ mediaType.label }\r\n                            uncheckedLabel={ mediaType.label }\r\n                            onCheck={ e => onToggleClick(e, mediaType.mediaType) } />\r\n                )) }\r\n            </GuxCardBeta>\r\n            <GuxTableBeta compact className=\"queue-status\" hidden={ (!debugMode) } >\r\n                <table slot=\"data\">\r\n                    <thead>\r\n                        <tr>\r\n                            <th>Queue</th>\r\n                            <th>Joined</th>\r\n                        </tr>\r\n                    </thead>\r\n                    <tbody>\r\n                        { queueList.map(queue => (\r\n                            <tr key={ queue.id }>\r\n                                <td>{ queue.name }</td>\r\n                                <td>{ (queue.joined ? 'Yes' : 'No') }</td>\r\n                            </tr>\r\n                        )) }\r\n                    </tbody>\r\n                </table>\r\n            </GuxTableBeta>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Home;"],"names":["registerElements","_React$useState","React","_React$useState2","_slicedToArray","queueList","setQueueList","_React$useState3","_React$useState4","configuredMediaTypes","setConfiguredMediaTypes","_React$useState5","_React$useState6","relevantMediaTypes","setRelevantMediaTypes","_React$useState7","undefined","_React$useState8","agentId","setAgentId","_React$useState9","_React$useState10","exception","setException","debugMode","useSelector","state","value","isCompliantMediaTypeQueue","queueName","supportedMediaTypes","queueNameParts","split","length","queueMediaType","toLowerCase","hasOwnProperty","filterApplicableMediaTypes","thisQueueList","thisSupportedMediaTypes","mediaTypes","_loop","thisQueueName","idx","name","thisQueueJoinStatus","joined","compliantMediaType","filter","mediaType","push","label","joinStatus","updateQueueStatus","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","newStatus","newQueueStatusList","thisQueueId","wrap","_context","prev","next","logToConsole","concat","id","GCloud","patchUserQueues","updateQueueList","t0","stop","_x","_x2","apply","arguments","updatedList","map","queue","foundElement","newQueueStatus","relevantAgentMedia","useEffect","loadGCXData","_ref2","_callee2","usersMeData","userQueuesData","_configuredMediaTypes","_context2","getCurrentUser","sent","getUserQueues","getSupportedMediaTypes","console","log","_jsxs","children","GuxInlineAlertBeta","accent","code","message","_jsx","GuxCardBeta","className","GuxToggle","checked","checkedLabel","uncheckedLabel","onCheck","e","detail","onToggleClick","GuxTableBeta","compact","hidden","slot"],"sourceRoot":""}