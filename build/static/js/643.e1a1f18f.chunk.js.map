{"version":3,"file":"static/js/643.e1a1f18f.chunk.js","mappings":"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","sources":["../node_modules/genesys-spark-components/dist/esm/floating-ui.dom.esm-483496c9.js"],"sourcesContent":["function getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition$1 = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\nconst min$1 = Math.min;\nconst max$1 = Math.max;\n\nfunction within(min$1$1, value, max$1$1) {\n  return max$1(min$1$1, min$1(value, max$1$1));\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min$1(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min$1$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1$1 ? min$1$1 - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset + alignmentOffset\n      }\n    };\n  }\n});\n\nconst sides = ['top', 'right', 'bottom', 'left'];\n\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[main], overflow[cross]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const axis = getMainAxisFromPlacement(placement);\n      const isXAxis = axis === 'x';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isXAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min$1(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min$1(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max$1(overflow.left, 0);\n        const xMax = max$1(overflow.right, 0);\n        const yMin = max$1(overflow.top, 0);\n        const yMax = max$1(overflow.bottom, 0);\n        if (isXAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return node instanceof getWindow(node).ShadowRoot || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const safari = isSafari();\n  const css = getComputedStyle$1(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !safari && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !safari && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction isSafari() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createEmptyCoords = v => ({\n  x: v,\n  y: v\n});\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createEmptyCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createEmptyCoords(0);\nfunction getVisualOffsets(element, isFixed, floatingOffsetParent) {\n  var _win$visualViewport, _win$visualViewport2;\n  if (isFixed === void 0) {\n    isFixed = true;\n  }\n  if (!isSafari()) {\n    return noOffsets;\n  }\n  const win = element ? getWindow(element) : window;\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== win) {\n    return noOffsets;\n  }\n  return {\n    x: ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0,\n    y: ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0\n  };\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createEmptyCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = getVisualOffsets(domElement, isFixedStrategy, offsetParent);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createEmptyCoords(1);\n  const offsets = createEmptyCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isSafari();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createEmptyCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createEmptyCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n  async getElementRects(_ref) {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(floating))\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate as a, arrow as b, computePosition as c, size as d, flip as f, hide as h, offset as o, shift as s };\n"],"names":["getAlignment","placement","split","getLengthFromAxis","axis","getSide","getMainAxisFromPlacement","includes","computeCoordsFromPlacement","_ref","rtl","coords","reference","floating","commonX","x","width","commonY","y","height","mainAxis","length","commonAlign","isVertical","computePosition$1","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","config","_config$placement","_config$strategy","strategy","_config$middleware","middleware","platform","validMiddleware","rects","_computeCoordsFromPla","statefulPlacement","middlewareData","resetCount","i","_validMiddleware$i","name","fn","_yield$fn","nextX","nextY","data","reset","_computeCoordsFromPla2","wrap","_context","prev","next","filter","Boolean","isRTL","sent","getElementRects","initialPlacement","elements","_objectSpread","_defineProperty","t0","abrupt","stop","_x","_x2","_x3","apply","arguments","evaluate","value","param","getSideObjectFromPadding","padding","top","right","bottom","left","expandPaddingObject","rectToClientRect","rect","detectOverflow","_x4","_x5","_detectOverflow","_callee9","state","options","_await$platform$isEle","_evaluate5","_evaluate5$boundary","boundary","_evaluate5$rootBounda","rootBoundary","_evaluate5$elementCon","elementContext","_evaluate5$altBoundar","altBoundary","_evaluate5$padding","paddingObject","altContext","element","clippingClientRect","offsetParent","offsetScale","elementClientRect","_context9","t1","isElement","t2","t3","t4","t5","contextElement","getDocumentElement","t6","t7","t8","t9","t10","getClippingRect","call","t11","getOffsetParent","getScale","t13","t12","t14","convertOffsetParentRelativeRectToViewportRelativeRect","t15","t16","min$1","Math","min","max$1","max","within","min$1$1","max$1$1","arrow","_callee2","_data","_ref4","_ref3","_ref3$padding","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","center","offset","shouldAddOffset","alignmentOffset","_context2","getDimensions","sides","oppositeSideMap","getOppositePlacement","replace","side","getAlignmentSides","alignment","mainAlignmentSide","main","cross","oppositeAlignmentMap","start","end","getOppositeAlignmentPlacement","getExpandedPlacements","oppositePlacement","getOppositeAxisPlacements","flipAlignment","direction","list","isStart","lr","rl","getSideList","map","concat","flip","_callee3","_middlewareData$flip","_evaluate","_evaluate$mainAxis","checkMainAxis","_evaluate$crossAxis","checkCrossAxis","specifiedFallbackPlacements","_evaluate$fallbackStr","fallbackStrategy","_evaluate$fallbackAxi","fallbackAxisSideDirection","_evaluate$flipAlignme","detectOverflowOptions","isBasePlacement","fallbackPlacements","placements","overflow","overflows","overflowsData","_getAlignmentSides","_middlewareData$flip2","_overflowsData$filter","nextIndex","nextPlacement","resetPlacement","_overflowsData$map$so","_placement","_context3","crossAxis","_objectWithoutProperties","_excluded","push","_toConsumableArray","every","index","d","sort","a","b","reduce","acc","getSideOffsets","isAnySideFullyClipped","some","hide","_callee4","_evaluate2","_evaluate2$strategy","offsets","_overflow","_offsets","_context4","_excluded2","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","convertValueToCoords","_x6","_x7","_convertValueToCoords","_callee10","mainAxisMulti","crossAxisMulti","rawValue","_ref6","alignmentAxis","_context10","_callee5","diffCoords","_context5","shift","_callee6","_objectSpread3","_evaluate3","_evaluate3$mainAxis","_evaluate3$crossAxis","_evaluate3$limiter","limiter","mainAxisCoord","crossAxisCoord","maxSide","_min","_max","_maxSide","_min2","_max2","limitedCoords","_context6","_excluded3","size","_callee7","_evaluate4","_evaluate4$apply","isXAxis","_rects$floating","heightSide","widthSide","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","maximumClippingWidth","maximumClippingHeight","xMin","xMax","yMin","yMax","nextDimensions","_context7","_excluded4","getWindow","node","_node$ownerDocument","ownerDocument","defaultView","window","getComputedStyle$1","getComputedStyle","isNode","Node","getNodeName","nodeName","toLowerCase","isHTMLElement","HTMLElement","Element","isShadowRoot","ShadowRoot","isOverflowElement","_getComputedStyle$","overflowX","overflowY","display","test","isTableElement","isContainingBlock","safari","isSafari","css","transform","perspective","containerType","backdropFilter","willChange","contain","CSS","supports","isLastTraversableNode","round","floor","createEmptyCoords","v","getCssDimensions","parseFloat","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","domElement","getBoundingClientRect","_getCssDimensions","Number","isFinite","noOffsets","getVisualOffsets","isFixed","floatingOffsetParent","_win$visualViewport","_win$visualViewport2","win","visualViewport","offsetLeft","offsetTop","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentIFrame","frameElement","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","document","documentElement","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getWindowScrollBarX","getParentNode","result","assignedSlot","parentNode","host","getNearestOverflowAncestor","body","getOverflowAncestors","scrollableAncestor","isBody","getClientRectFromClippingAncestor","clippingAncestor","html","clientWidth","clientHeight","visualViewportBased","getViewportRect","scroll","scrollWidth","scrollHeight","getDocumentRect","getInnerBoundingClientRect","hasFixedPositionAncestor","stopNode","position","getTrueOffsetParent","polyfill","currentNode","getContainingBlock","getRectRelativeToOffsetParent","isOffsetParentAnElement","offsetRect","elementClippingAncestors","cache","cachedResult","get","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","set","getClippingElementAncestors","this","_c","clippingAncestors","firstClippingAncestor","clippingRect","accRect","_this","_callee8","getOffsetParentFn","getDimensionsFn","_context8","getClientRects","Array","from","autoUpdate","update","_options","_options$ancestorScro","ancestorScroll","_options$ancestorResi","ancestorResize","_options$elementResiz","elementResize","ResizeObserver","_options$layoutShift","layoutShift","IntersectionObserver","_options$animationFra","animationFrame","referenceEl","ancestors","forEach","addEventListener","passive","frameId","cleanupIo","onMove","timeoutId","io","root","cleanup","clearTimeout","disconnect","refresh","skip","threshold","_element$getBoundingC","rootMargin","isFirstUpdate","handleObserve","e","observe","entries","ratio","intersectionRatio","setTimeout","observeMove","reobserveFrame","resizeObserver","firstEntry","_slicedToArray","target","unobserve","cancelAnimationFrame","requestAnimationFrame","prevRefRect","frameLoop","nextRefRect","removeEventListener","computePosition","Map","mergedOptions","platformWithCache"],"sourceRoot":""}